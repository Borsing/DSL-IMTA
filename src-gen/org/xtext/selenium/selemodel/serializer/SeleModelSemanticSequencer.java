/*
 * generated by Xtext 2.10.0
 */
package org.xtext.selenium.selemodel.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.selenium.selemodel.seleModel.Assertion;
import org.xtext.selenium.selemodel.seleModel.Attribuable;
import org.xtext.selenium.selemodel.seleModel.Attribut;
import org.xtext.selenium.selemodel.seleModel.Attribution;
import org.xtext.selenium.selemodel.seleModel.Check;
import org.xtext.selenium.selemodel.seleModel.Choose;
import org.xtext.selenium.selemodel.seleModel.Click;
import org.xtext.selenium.selemodel.seleModel.Condition;
import org.xtext.selenium.selemodel.seleModel.Container;
import org.xtext.selenium.selemodel.seleModel.Containers;
import org.xtext.selenium.selemodel.seleModel.Declaration;
import org.xtext.selenium.selemodel.seleModel.Expression;
import org.xtext.selenium.selemodel.seleModel.Fill;
import org.xtext.selenium.selemodel.seleModel.Function;
import org.xtext.selenium.selemodel.seleModel.FunctionCall;
import org.xtext.selenium.selemodel.seleModel.Main;
import org.xtext.selenium.selemodel.seleModel.Model;
import org.xtext.selenium.selemodel.seleModel.Navigate;
import org.xtext.selenium.selemodel.seleModel.OpenBrowser;
import org.xtext.selenium.selemodel.seleModel.SeleModelPackage;
import org.xtext.selenium.selemodel.seleModel.Uncheck;
import org.xtext.selenium.selemodel.seleModel.Var;
import org.xtext.selenium.selemodel.services.SeleModelGrammarAccess;

@SuppressWarnings("all")
public class SeleModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SeleModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SeleModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SeleModelPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case SeleModelPackage.ATTRIBUABLE:
				sequence_Attribuable(context, (Attribuable) semanticObject); 
				return; 
			case SeleModelPackage.ATTRIBUT:
				sequence_Attribut(context, (Attribut) semanticObject); 
				return; 
			case SeleModelPackage.ATTRIBUTION:
				sequence_Attribution(context, (Attribution) semanticObject); 
				return; 
			case SeleModelPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case SeleModelPackage.CHOOSE:
				sequence_Choose(context, (Choose) semanticObject); 
				return; 
			case SeleModelPackage.CLICK:
				sequence_Click(context, (Click) semanticObject); 
				return; 
			case SeleModelPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case SeleModelPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case SeleModelPackage.CONTAINERS:
				sequence_Containers(context, (Containers) semanticObject); 
				return; 
			case SeleModelPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case SeleModelPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case SeleModelPackage.FILL:
				sequence_Fill(context, (Fill) semanticObject); 
				return; 
			case SeleModelPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case SeleModelPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case SeleModelPackage.MAIN:
				sequence_Main(context, (Main) semanticObject); 
				return; 
			case SeleModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SeleModelPackage.NAVIGATE:
				sequence_Navigate(context, (Navigate) semanticObject); 
				return; 
			case SeleModelPackage.OPEN_BROWSER:
				sequence_OpenBrowser(context, (OpenBrowser) semanticObject); 
				return; 
			case SeleModelPackage.UNCHECK:
				sequence_Uncheck(context, (Uncheck) semanticObject); 
				return; 
			case SeleModelPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     ((att1=Attribuable att2=Attribuable) | (con1=Container con2=Container))
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribuable returns Attribuable
	 *
	 * Constraint:
	 *     (str=STRING | attr=Attribut | ref=[Var|ID])
	 */
	protected void sequence_Attribuable(ISerializationContext context, Attribuable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribut returns Attribut
	 *
	 * Constraint:
	 *     ((container=Container (champ=Champ | len=Length)) | (containers=Containers len=Length))
	 */
	protected void sequence_Attribut(ISerializationContext context, Attribut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribution returns Attribution
	 *
	 * Constraint:
	 *     (var=[Var|ID] attb=Attribuable)
	 */
	protected void sequence_Attribution(ISerializationContext context, Attribution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.ATTRIBUTION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.ATTRIBUTION__VAR));
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.ATTRIBUTION__ATTB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.ATTRIBUTION__ATTB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributionAccess().getVarVarIDTerminalRuleCall_0_0_1(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAttributionAccess().getAttbAttribuableParserRuleCall_2_0(), semanticObject.getAttb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Check
	 *     Check returns Check
	 *
	 * Constraint:
	 *     (container=Container | containers=Containers)
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Choose
	 *     Choose returns Choose
	 *
	 * Constraint:
	 *     (container=Container attb=Attribuable)
	 */
	protected void sequence_Choose(ISerializationContext context, Choose semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.CHOOSE__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.CHOOSE__CONTAINER));
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.CHOOSE__ATTB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.CHOOSE__ATTB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChooseAccess().getContainerContainerParserRuleCall_1_0(), semanticObject.getContainer());
		feeder.accept(grammarAccess.getChooseAccess().getAttbAttribuableParserRuleCall_2_0(), semanticObject.getAttb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Click
	 *     Click returns Click
	 *
	 * Constraint:
	 *     container=Container
	 */
	protected void sequence_Click(ISerializationContext context, Click semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.CLICK__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.CLICK__CONTAINER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClickAccess().getContainerContainerParserRuleCall_1_0(), semanticObject.getContainer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (champ=Champ (str=STRING | ref=[Var|ID]))
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (typeContainer=TypeContainer conditions+=Condition* (hierarchy+=ParentContainer | hierarchy+=ChildContainer)*)
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Containers returns Containers
	 *
	 * Constraint:
	 *     (typeContainer=TypeContainer conditions+=Condition*)
	 */
	protected void sequence_Containers(ISerializationContext context, Containers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     var+=Var
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (dec=Declaration | att=Attribution | act=Action | ass=Assertion)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Fill
	 *     Fill returns Fill
	 *
	 * Constraint:
	 *     (container=Container attb=Attribuable)
	 */
	protected void sequence_Fill(ISerializationContext context, Fill semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.FILL__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.FILL__CONTAINER));
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.FILL__ATTB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.FILL__ATTB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFillAccess().getContainerContainerParserRuleCall_1_0(), semanticObject.getContainer());
		feeder.accept(grammarAccess.getFillAccess().getAttbAttribuableParserRuleCall_2_0(), semanticObject.getAttb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *     Expression returns FunctionCall
	 *
	 * Constraint:
	 *     (ref=[Function|ID] (param+=Attribuable param+=Attribuable*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (param+=Declaration param+=Declaration*)? expressions+=Expression*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Main returns Main
	 *
	 * Constraint:
	 *     expressions+=Expression+
	 */
	protected void sequence_Main(ISerializationContext context, Main semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (main=Main functions+=Function*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Navigate
	 *     Navigate returns Navigate
	 *
	 * Constraint:
	 *     attb=Attribuable
	 */
	protected void sequence_Navigate(ISerializationContext context, Navigate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.NAVIGATE__ATTB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.NAVIGATE__ATTB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigateAccess().getAttbAttribuableParserRuleCall_1_0(), semanticObject.getAttb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns OpenBrowser
	 *     OpenBrowser returns OpenBrowser
	 *
	 * Constraint:
	 *     browser=Browsers
	 */
	protected void sequence_OpenBrowser(ISerializationContext context, OpenBrowser semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.OPEN_BROWSER__BROWSER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.OPEN_BROWSER__BROWSER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOpenBrowserAccess().getBrowserBrowsersParserRuleCall_1_0(), semanticObject.getBrowser());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Uncheck
	 *     Uncheck returns Uncheck
	 *
	 * Constraint:
	 *     (container=Container | containers=Containers)
	 */
	protected void sequence_Uncheck(ISerializationContext context, Uncheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleModelPackage.Literals.VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleModelPackage.Literals.VAR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
